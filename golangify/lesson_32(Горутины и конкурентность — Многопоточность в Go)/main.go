package main

import (
	"fmt"
	"math/rand"
	"strings"
	"time"
)

// /////////////////////// task_1 ///////////////////
// Запуск горутины в Golang
func task_1() {
	go sleepyGopher(1) // Начало горутины
	go myFunk()
	time.Sleep(4 * time.Second) // Ожидание храпа гофера
	fmt.Println("End")
} // Здесь все горутины останавливаются

func sleepyGopher(n int) {
	time.Sleep(3 * time.Second) // гофер спит
	fmt.Printf("... snore ..., task_%v\n", n)
}

func myFunk() {
	fmt.Println("Hellow world!")
}

// Создание нескольких горутин в Golang
func task_2() {
	for i := 0; i < 5; i++ {
		go sleepyGopher(i)
	}
	time.Sleep(4 * time.Second)

	// В данном коде есть проблема. Он ждет четыре секунды, хотя нужно подождать только три секунды.
	// Если горутины не только спят но и делают другие операции, то мы не сможем узнать, сколько им потребуется времени для завершения работы.
	// Нам потребуется найти способ, через который код сможет узнать, когда горутины завершаются. К счастью, для этого в Go есть каналы.
}

////////////////////////////////////////////////////

// /////////////////////// task_3 ///////////////////
// Каналы общения между горутинами в Golang
func task_3() {
	// Для создания канала используется встроенная функция make, та же самая, что используется для создания карт и срезов.
	// У каналов есть тип, что уточняется во время их создания. Следующий канал может отправлять и принимать только целочисленные integer значения:
	// c := make(chan int)

	// c <- 99 // Следующий код посылает значение 99:

	// //  В следующем коде мы получаем значение из канала c и сохраняем это значение а переменную r.
	// r := <-c

	// fmt.Println(r)

	c := make(chan int)
	c_h := make(chan string)

	go helloWorkd(c_h)

	h := <-c_h
	fmt.Println(h)

	for i := 0; i < 5; i++ {
		go gorutinaChenal(i, c)
	}
	for i := 0; i < 5; i++ {
		gopherID := <-c // Прием переменной через канал (Ждем ответ от всех Горутин)
		fmt.Println("gopher ", gopherID, " has finished sleeping")
	}

}

func gorutinaChenal(id int, c chan int) {
	timeRandom := time.Duration(rand.Intn(5) + 1)
	fmt.Printf("Random second: %v, id: %v\n", timeRandom, id)
	time.Sleep(timeRandom * time.Second)
	fmt.Println("... ", id, " snore ...")

	c <- id // передача переменной через канал
}

func helloWorkd(c_h chan string) {
	h := fmt.Sprintln("Hellow World")
	c_h <- h
}

////////////////////////////////////////////////////

// /////////////////////// task_4 ///////////////////
// Использование select в канале горутин
func task_4() {
	// В следующем листинге используется time.After для создания канала тайм-аута,
	// а затем используется select для ожидания каналом сонных гоферов и тайм-аута канала.
	c := make(chan int)
	for i := 0; i < 5; i++ {
		go gorutinaChenal(i, c)
	}

	timeout := time.After(2 * time.Second) // Создание ограничения по времени длоя Горутины
	for i := 0; i < 5; i++ {
		select {
		case gopherID := <-c: // Ждем пока какая нибудь Горутина вернет ответ
			fmt.Println("gopher ", gopherID, " has finished sleeping")
		case <-timeout: // Жлем оканчания времени (Возвращает канал)
			fmt.Println("my patience ran out")
			return
		}
	}

	// Данный паттерн полезен, когда вам нужно ограничить время на выполнения определенной операции.
	// Поместив действие внутрь горутины и отправив его каналу, когда тот завершен, можно добиться фиксированного времени практически для всего в Go.
}

///////////////////////////////////////////////////////

// /////////////////////// task_5 ///////////////////
// Каналы nil в Golang ничего не делают
func task_5() {
	//Из-за того, что вам нужно явно создать каналы через make, вам может показаться интересным, что произойдет, если вы используете значения каналов,
	// что не были созданы. Как и в случае с картами, срезами и указателями, каналы могут быть nil. nil является их нулевым значением по умолчанию.

	// Если вы попробуете использовать канал nil, он не вызовет сбой — вместо этого операция (отправки или приема) заблокируется навечно, как канал,
	// что никогда ничего не отправляет или не получает. Исключением является close, который подробнее будет описан далее.
	// Если вы попытаетесь закрыть канал nil, произойдет сбой.
}

/////////////////////////////////

// /////////////////////// task_6 ///////////////////
// Блокировка и deadlock в Golang
func task_6() {
	// Когда горутина ожидает отправки или получения данных из канала, мы говорим, что она заблокирована. Это похоже на то,
	// как если бы мы написали какой-то код с циклом, который выполняется вечно, ничего не делая, и на первый взгляд они выглядят точно так же.
	// Но если вы запустите бесконечный цикл в программе на ноутбуке, вы можете обнаружить, что вентилятор начинает гудеть, компьютер нагревается,
	// потому что он совершает много работы. Если сравнить, то заблокированная горутина не требует ресурсов (кроме небольшого объема памяти,
	// 	используемой самой горутиной). Она тихо ждет, пока все, что ее блокирует, перестанет ее блокировать.

	// Когда одна или несколько горутин блокируются из-за того, что никогда не произойдет, это называется тупиком или deadlock.
	// Программа будет зависать или сбиваться. Deadlock может быть  вызван чем-то простым:
	c := make(chan int)
	<-c // вызовет Deadlock

}

//////////////////////////////////////////

// /////////////////////// task_7 ///////////////////
// Объединение горутин в конвейер
func task_7() {
	c0 := make(chan string)
	c1 := make(chan string)
	go sourceGofer(c0)
	go filterGofer(c0, c1)
	printGofer(c1)
}

func sourceGofer(dawstream chan string) {
	for _, i := range []string{"hello world", "a bad apple", "new", "goodbye all"} {
		dawstream <- i
	}
	// не используя clouse
	// dawstream <- ""
	close(dawstream)
}

func filterGofer(upstream, dawstream chan string) {
	for {
		item, ok := <-upstream
		if !ok {
			// не используя clouse
			// if item == "" {
			// dawstream <- ""
			close(dawstream)
			return
		}
		if !strings.Contains(item, "bad") {
			dawstream <- item
		}
	}
}

func printGofer(upstream chan string) {
	// не используя clouse
	// for {
	// 	item := <-upstream
	// 	if item == "" {
	// 		return
	// 	}
	// 	fmt.Println(item)
	// }

	// использую clouse
	for i := range upstream {
		fmt.Println(i)
	}

}

/////////////////////////////////////////

// На данный момент у нас есть одна проблема с кодом для конвейера. Мы используем пустую строку как способ обозначения, что больше нет данных для обработки.
// Но что, если нам нужно обработать пустую строку, предположим, у нее другое значение? Вместо строк мы могли бы отправить значение структуры,
// содержащее как нужную строку, так и булево поле, говорящее, является ли значение последним.

// После закрытия канала вы не можете записать в него новые значения (будет сбой при попытке),
// и любое чтение вернется сразу с нулевым значением для типа (в данном случае это пустая строка).

// Как узнать, был ли канал закрыт? Следующим образом:
// v, ok := <-c

func main() {
	// task_1() // Запуск горутины
	// task_2() // Создание нескольких горутин в Golang
	// task_3() // Каналы общения между горутинами в Golang
	// task_4() // Использование select в канале горутин
	// task_5() // Каналы общения между горутинами в Golang
	// task_6() // Блокировка и deadlock в Golang
	task_7() // Объединение горутин в конвейер
}
